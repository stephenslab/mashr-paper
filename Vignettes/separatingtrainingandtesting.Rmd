---
title: "SampleRunVignette"
output: html_document
---

First, we want to load the code:

```{r}

source("~/matrix_ash/R/main.R")
source("~/matrix_ash/R/mixEm.R")

library("bigmemory")
library("SQUAREM")
library("mvtnorm")

```

Then, we need to load our matrix of 'strong' t statistics to create the covariance matrices as well as the matrix of factors from our SFA model. In this example, we will not use the additional BMA configurations (i.e., bma=FALSE). Also load the maximum beta hats and t statistics for grid selection.

```{r}

set.seed(123)
setwd("~/Dropbox/test/")
R=5

sigma=diag(rnorm(R,0,3))##big effects for input max effects
Sigma=t(sigma)%*%sigma
b.gp.hat=rmvnorm(15000,mean=rep(0,R),sigma=Sigma)
se.gp.hat=matrix(runif(15000*R,0.2,0.5),ncol=R,nrow=15000)
t.stat=b.gp.hat/se.gp.hat


R=ncol(b.gp.hat)#number of tissues
X.t=as.matrix(t.stat)
#X.real=X.t[which(truth$config!=0),]
X.real=X.t
X.c=apply(X.real,2,function(x) x-mean(x)) ##Column centered matrix of t statistics
R=ncol(X.t)
M=nrow(X.c)


##make up fake sfa factors using svd##
lambda=svd(X.t)$u
factors=svd(X.t)$v

##but let's not use them since they are artificial, i.e., Q=0

covmat=compute.covmat(b.gp.hat,se.gp.hat,Q=0,X.c,lambda,P=2,A="singlerun",factor.mat=factors,bma=FALSE)

K=length(covmat)
K
covmat[[K]]
```

Now, we let's remove these strong tstats and split our new data into test and training. This will compute the HM weights on training data and return a file of likelihoods for the training data, 

```{r}
rm(b.gp.hat)
rm(se.gp.hat)



sigma=diag(rnorm(R,0,1))##small effects for training data
Sigma=t(sigma)%*%sigma
b.hat=rmvnorm(15000,mean=rep(0,R),sigma=Sigma)
se.hat=matrix(runif(15000*R,0.2,0.5),ncol=R,nrow=15000)


J=nrow(b.hat)

b.train=b.hat[1:1000,]
se.train=se.hat[1:1000,]

compute.hm.train(train.b = b.train,se.train = se.train,covmat = covmat,A="filename") ##compute the HM weights on training data

```
Note creation of three files: pis, a pdf of pis, and a matrix  of likelihoods of training data.

Now,we remove the training data and create our test data.

```{r}
rm(b.train)
rm(se.train)

b.test=b.hat[1001:nrow(b.hat),]
se.test=se.hat[1001:nrow(se.hat),]
````

We read in the previously computed pis and the covariane matrix and compute the test likelihood and corresponding weights. Note the return of a file of test likeilihoods and posterior weights. Here, I will only do the computation for 10 gene-snp pairs. 

```{r}
A="filename"
pis=readRDS(paste0("pis",A,".rds"))$pihat

barplot(t(as.matrix(pis)))
(covmat[[which.max(pis)]])


compute.lik.test(b.gp.hat = b.test,J = 10,se.gp.hat = se.test,covmat,A="filename",pis) 
```

We could stop here, but we might also want to compute the posterior means for each componenet and the weighted 'grand mean', as well as the weighted tail probabilities. The componenet specific quanitites are computed in 'compute.mix.test' and the weighted quantities in 'test.quant'. We can choose to save the rds object if 'save = TRUE' but this consumes a lot of space.

```{r}
all.arrays=compute.mix.test(b.gp.hat = b.test,J = 10,se.gp.hat = se.test,covmat = covmat,A="filename",save=FALSE)##componenet specific posterior means, variances, tail probabilities
test.quant(A="filename",all.arrays)##weighted posterior quantities
```


You can test to make sure the array computations are accurate for a particular snp. First, we check the component specific snp and then we check the weighting.

```{r}
##test for snp 1##
j=1
b.mle=as.vector(t(b.test[j,]))##turn i into a R x 1 vector
V.gp.hat=diag(se.test[j,])^2
V.gp.hat.inv <- solve(V.gp.hat)
k=10
U.gp1kl <- (post.b.gpkl.cov(V.gp.hat.inv, covmat[[k]]))
(mu.gp1kl <- as.array(post.b.gpkl.mean(b.mle, V.gp.hat.inv, U.gp1kl)))

all.arrays$post.means[j,k,]

A="filename"
post.means=read.table(paste0("post.mean.",A,".txt"))
post.weights=readRDS("post.weight.filename.rds")

(post.weights[j,]%*%all.arrays$post.means[j,,])
(post.means[j,])