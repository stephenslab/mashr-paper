---
title: "PowervsAccuracy_tspec"
output: html_document
---

Here, I want to demonstrate that MASH is the best accuracy for power exchange using the tspec simulated data.

```{r,echo=FALSE,cache=TRUE}
data=readRDS("~/Dropbox/simdata_tspec.rds")
t=data$tstat;bhat=data$betahat;sebetahat=data$sebetahat;beta=data$beta;v.j=matrix(rep(1,ncol(t)*nrow(t)),ncol=ncol(t),nrow=nrow(t))
t.truth.test=beta/sebetahat
mash.means=read.table("~/Dropbox/testtissuespecposterior.means.txt")[,-1]
univariate.ash.pm=read.table("~/Dropbox/univariate.ash.pm.tspec.txt")
bma.pm=read.table("~/Dropbox/testimBMAonly_tspecposterior.means.txt")[,-1]
lfsr.bma=read.table("~/Dropbox/testimBMAonly_tspeclfsr.txt")[,-1]
lfsr.mash=read.table("~/Dropbox/testtissuespeclfsr.txt")[,-1]
lfsr.ash=read.table("~/Dropbox/univariate.ash.lfsr.tspec.txt")

```

REcall RMSE result:
```{r rmse}

sqrt(mean((t.truth.test[1:10000,]-mash.means)^2))
sqrt(mean((t.truth.test[1:10000,]-univariate.ash.pm)^2))
sqrt(mean((t.truth.test[1:10000,]-bma.pm)^2))



sqrt(mean((beta[1:10000,]-mash.means*sebetahat)^2))
sqrt(mean((beta[1:10000,]-univariate.ash.pm*sebetahat)^2))
sqrt(mean((beta[1:10000,]-bma.pm*sebetahat)^2))

cor(unlist(as.vector(t.truth.test[1:10000,])), unlist(as.vector(bma.pm)))
cor(unlist(as.vector(t.truth.test[1:10000,])), unlist(as.vector(mash.means)))
cor(unlist(as.vector(t.truth.test[1:10000,])), unlist(as.vector(univariate.ash.pm)))


cor(unlist(as.vector(beta[1:10000,])), unlist(as.vector(bma.pm*sebetahat)))
cor(unlist(as.vector(beta[1:10000,])), unlist(as.vector(mash.means*sebetahat)))
cor(unlist(as.vector(beta[1:10000,])), unlist(as.vector(univariate.ash.pm*sebetahat)))
```

And here we plot number sig vs significance threshold:
```{r echo=FALSE,cache=TRUE}
beta=as.matrix(beta[1:10000,])
lfsr.mash=as.matrix(lfsr.mash)
lfsr.ash=as.matrix(lfsr.ash)
lfsr.bma=as.matrix(lfsr.bma)


sig_func=function(beta,lfsr,thresh){
sapply(seq(1:nrow(beta)),function(x){
  nonzero=which(beta[x,]!=0)
  sigs=which(lfsr[x,]<thresh)
  length(intersect(sigs,nonzero))
})
}


# mash.sigs=sig_func(beta,lfsr.mash,thresh=0.10)
# ash.sigs=sig_func(beta,lfsr.ash,thresh=0.10)
# bma.sigs=sig_func(beta,lfsr.bma,thresh=0.10)



plot(0.05,sum(sum(beta!=0&lfsr.mash<0.05)),col="blue",ylim=c(0,10000),xlim=c(0.01,0.10),pch=2,ylab="NumberofTrueAssociationsCaptured",xlab="LFSRThreshold")

for(thresh in seq(from = 0.01,to = 0.1,by = 0.001)){
points(thresh,sum(beta!=0&lfsr.mash<thresh),col="blue",pch=1)}
for(thresh in seq(from = 0.01,to = 0.1,by = 0.001)){
points(thresh,sum(beta!=0&lfsr.bma<thresh),col="red",pch=2)}
for(thresh in seq(from = 0.01,to = 0.1,by = 0.001)){
points(thresh,sum(beta!=0&lfsr.ash<thresh),col="green",pch=3)}

legend("bottom",legend=c("MASH","BMALite","ASH"),pch=c(2,1,3),col=c("blue","red","green"))
title("Number of True Association Captured vs Significance (LFSR) Threshold, with TS")
```
We can also ask if we get the sign correct. Here, for a given LFSR threshold, we ask how many times we call the sign correctly:


```{r echo=FALSE,cache=TRUE}
beta=as.matrix(beta[1:10000,])
mash.means=as.matrix(mash.means)
ash.means=as.matrix(univariate.ash.pm)
bma.means=as.matrix(bma.pm)

##this will be positive if the signs are the same and negative if signs are different##

sign.test.mash=beta*mash.means
sign.test.ash=beta*ash.means
sign.test.bma=beta*bma.means

plot(0.05,sum(sign.test.mash>0&lfsr.mash<0.05),col="blue",ylim=c(0,15000),xlim=c(0.01,0.10),pch=2,ylab="SignCorrect",xlab="LFSRThreshold")

for(thresh in seq(from = 0.01,to = 0.1,by = 0.001)){
points(thresh,sum(sign.test.mash>0&lfsr.mash<0.05),col="blue",pch=1)}
for(thresh in seq(from = 0.01,to = 0.1,by = 0.001)){
points(thresh,sum(sign.test.bma>0&lfsr.bma<0.05),col="red",pch=2)}
for(thresh in seq(from = 0.01,to = 0.1,by = 0.001)){
points(thresh,sum(sign.test.ash>0&lfsr.ash<0.05),col="green",pch=3)}

legend("bottom",legend=c("MASH","BMALite","ASH"),pch=c(2,1,3),col=c("blue","red","green"))
title("Sign Correct vs Significance (LFSR) Threshold, with TS")
```



