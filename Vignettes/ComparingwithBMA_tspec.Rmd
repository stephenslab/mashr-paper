---
title: "comarpingwithbmatissuespec"
output: html_document
---

The purpose is to simulate according to the patterns of sharing present in the GTEX V6 Data, where 100 snps in cis of 500 genes, $pi0$ is 0.80, and there is sharing according to gtex covmats 2:9 and 35% to tissue spec. We now want to compare to the results using the bmalite configs for inference.

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=TRUE)
source("~/matrix_ash/R/main.R")
```

```{r, eval=FALSE}
source("~/matrix_ash/R/main.R")
source("~/matrix_ash/R/mixEm.R")
source("~/matrix_ash/R/NewSimulations.R")
data=factor_sim_new(J = 50000,tspec=5)##simulate 50000 gene snp pairs, with 5 tissue specific tissues
saveRDS(data,"~/Dropbox/simdata_tspec.rds")
c=apply(t,1,function(x){max(abs(x))})
maxes=order(c,decreasing = TRUE)[1:400]##take top 100 gene snp pairs
max.t=t[maxes,]
##sfa -gen ./maxt.txt -g 400 -n 44 -o tri_sim_strongt i -k 5

factor.mat=as.matrix(read.table("~/Dropbox/tri_sim_spect_F.out"))
lambda.mat=as.matrix(read.table("~/Dropbox/tri_sim_spect_lambda.out"))
v.j=matrix(rep(1,ncol(t)*nrow(t)),ncol=ncol(t),nrow=nrow(t))
covmat=compute.covmat(b.gp.hat = t,sebetahat = v.j,Q =5, t.stat=max.t,lambda.mat=lambda.mat,P=3,A="testim_tspec", factor.mat = factor.mat,bma = TRUE)##Note that here, we perform our inference including the BMA configs.
```

To determine how much is tissue specific:
```{r definedata,eval=TRUE}
data=readRDS("~/Dropbox/simdata_tspec.rds")
t=data$tstat;bhat=data$betahat;sebetahat=data$sebetahat;beta=data$beta
sum(data$component.id>8)/length(data$component.id)
t=data$tstat;bhat=data$betahat;sebetahat=data$sebetahat;beta=data$beta;v.j=matrix(rep(1,ncol(t)*nrow(t)),ncol=ncol(t),nrow=nrow(t))
c=apply(t,1,function(x){max(abs(x))})
maxes=order(c,decreasing = TRUE)[1:400]##take top 100 gene snp pairs
max.t=t[maxes,]
##sfa -gen ./maxt.txt -g 400 -n 44 -o tri_sim_strongt i -k 5
covmat=compute.covmat.bma.only(b.gp.hat = t,sebetahat = v.j,A="testimBMAonly_tspec")
```

Now, let's fit the model using the random set of 20,000 gene snp pairs.

```{r, eval=FALSE}
A="testimBMAonly_tspec"
compute.hm.train(train.b = t[1:20000,],se.train = v.j[1:20000,],covmat = covmat,A)

```

Now, we can compute posteriors for, say, the first 10000 gene snp pairs:

```{r computeposteriorsbma,eval=FALSE}
A="testsimBMAonly"
pis=readRDS(paste0("pis",A,".rds"))$pihat
b.test=t[1:10000,]
se.test=v.j[1:10000,]
weightedquants=lapply(seq(1:10000),function(j){total.quant.per.snp(j,covmat,b.gp.hat=b.test,se.gp.hat = se.test,pis,A=A,checkpoint = FALSE)})
```

Now, let's compute the RMSE:

```{r rmsebma}
t.truth.test=beta/sebetahat
post.means=read.table(paste0("~/Dropbox/",A,"posterior.means.txt")[,-1]
sqrt(mean((t.truth.test[1:10000,]-post.means)^2))
```

Gutcheck:
```{r gutcheck,eval=FALSE}
j=sample.int(100,1)
k=which.max(post.weights)
b.mle=as.vector(t(t[j,]))##turn i into a R x 1 vector
V.j.hat=diag(v.j[j,])^2
V.j.hat.inv <- solve(V.j.hat)
lik.snp=lik.func(b.mle,V.j.hat,covmat)
post.weights=t(lik.snp*pis/sum(lik.snp*pis))
a=post.array.per.snp(j,covmat = covmat,b.gp.hat = t,se.gp.hat = v.j)
U.gp1kl <- (post.b.gpkl.cov(V.j.hat.inv, covmat[[k]]))
mu.gp1kl <- as.array(post.b.gpkl.mean(b.mle, V.j.hat.inv, U.gp1kl))

plot(a$post.means[k,],mu.gp1kl)
plot(a$post.covs[k,],diag(U.gp1kl))
plot(as.matrix(post.means[j,]),as.matrix(post.weights%*%a$post.means))

Now, let's fit the model using the random set of 20,000 gene snp pairs.

```{r, eval=FALSE}

compute.hm.train(train.b = t[1:20000,],se.train = v.j[1:20000,],covmat = covmat,A="Simulations")

```

Now, we can compute posteriors for, say, the first 10000 gene snp pairs:

```{r computeposterior,eval=FALSE}
A="Simulations"
pis=readRDS(paste0("pis",A,".rds"))$pihat
b.test=t[1:10000,]
se.test=v.j[1:10000,]
weightedquants=lapply(seq(1:10000),function(j){total.quant.per.snp(j,covmat,b.gp.hat=b.test,se.gp.hat = se.test,pis,A="Simulations",checkpoint = FALSE)})
```

We can compute the root mean squared error using MASH:
```{r RMSE}
data=readRDS("~/Dropbox/simdata.rds")
t=data$tstat;bhat=data$betahat;sebetahat=data$sebetahat;beta=data$beta;v.j=matrix(rep(1,ncol(t)*nrow(t)),ncol=ncol(t),nrow=nrow(t))
covmat=readRDS("~/Dropbox/covmattestim.rds")

t.truth.test=beta/sebetahat
post.means.mash=read.table("~/Dropbox/Simulationsposterior.means.txt")[,-1]
sqrt(mean((t.truth.test[1:10000,]-post.means.mash)^2))
```


Now we want to perform the same inference, but using the BMAlite configs to estimate the posteriors.

```{r estimate.with.bma}
data=readRDS("~/Dropbox/simdata.rds")
t=data$tstat;bhat=data$betahat;sebetahat=data$sebetahat;beta=data$beta;v.j=matrix(rep(1,ncol(t)*nrow(t)),ncol=ncol(t),nrow=nrow(t))
c=apply(t,1,function(x){max(abs(x))})
maxes=order(c,decreasing = TRUE)[1:400]##take top 100 gene snp pairs
max.t=t[maxes,]
##sfa -gen ./maxt.txt -g 400 -n 44 -o tri_sim_strongt i -k 5
v.j=matrix(rep(1,ncol(t)*nrow(t)),ncol=ncol(t),nrow=nrow(t))
covmat=compute.covmat.bma.only(b.gp.hat = t,sebetahat = v.j,A="testimBMAonly")
```

Now, let's fit the model using the random set of 20,000 gene snp pairs.

```{r, eval=FALSE}
A="testsimBMAonly"
compute.hm.train(train.b = t[1:20000,],se.train = v.j[1:20000,],covmat = covmat,A)

```

Now, we can compute posteriors for, say, the first 10000 gene snp pairs:

```{r computeposteriorsbma,eval=FALSE}
A="testsimBMAonly"
pis=readRDS(paste0("pis",A,".rds"))$pihat
b.test=t[1:10000,]
se.test=v.j[1:10000,]
weightedquants=lapply(seq(1:10000),function(j){total.quant.per.snp(j,covmat,b.gp.hat=b.test,se.gp.hat = se.test,pis,A=A,checkpoint = FALSE)})
```

Now, let's compute the RMSE:

```{r rmsebma}
t.truth.test=beta/sebetahat
post.means=read.table("~/Dropbox/testsimBMAonlyposterior.means.txt")[,-1]
sqrt(mean((t.truth.test[1:10000,]-post.means)^2))
```

Gutcheck:
```{r gutcheck,eval=FALSE}
j=sample.int(100,1)
k=which.max(post.weights)
b.mle=as.vector(t(t[j,]))##turn i into a R x 1 vector
V.j.hat=diag(v.j[j,])^2
V.j.hat.inv <- solve(V.j.hat)
lik.snp=lik.func(b.mle,V.j.hat,covmat)
post.weights=t(lik.snp*pis/sum(lik.snp*pis))
a=post.array.per.snp(j,covmat = covmat,b.gp.hat = t,se.gp.hat = v.j)
U.gp1kl <- (post.b.gpkl.cov(V.j.hat.inv, covmat[[k]]))
mu.gp1kl <- as.array(post.b.gpkl.mean(b.mle, V.j.hat.inv, U.gp1kl))

plot(a$post.means[k,],mu.gp1kl)
plot(a$post.covs[k,],diag(U.gp1kl))
plot(as.matrix(post.means[j,]),as.matrix(post.weights%*%a$post.means))
